/*
 * ID für test.minilock
 * 
 * andre.simon1@gmx.de
 * 27nfcLfQB1WnWPmskwgZ8w82SzN9azmsgi76bsdp1euhGt
 * 
 * annoys coding sailer decrypted incrementation retention patterns
 * 

 * andre@myhost ~/P/t/mlock> /home/andre/Projekte/mlock/src/mlock -s andre.simon2@gmx.de
Your miniLock-ID: 2RcYddVzLRhfXp7RiUR89GG1huLomuKvyDiQUD1UknkEo <<< 

andre@myhost ~/P/t/mlock> /home/andre/Projekte/mlock/src/mlock -s andre.simon3@gmx.de
Your miniLock-ID: sE78JKs5ZfhgbQmFTCH5QmnMqnT1iGLSRVABNPdA8j3MJ

andre@myhost ~/P/t/mlock> /home/andre/Projekte/mlock/src/mlock -s andre.simon4@gmx.de
Your miniLock-ID: 6iD7ofp2iy4oJ2iJFszVFDKWWmKhvwERRJUi22e9ggwLr

andre@myhost ~/P/t/mlock> /home/andre/Projekte/mlock/src/mlock -s andre.simon5@gmx.de
Your miniLock-ID: 8mpeMt1rUoPVQSoRJNxno36YwKASZu7XG5xWKgrSakMbk
 * 
 */

//TODO TEST OB ZIELDATEi schon ex., option dateinamen, ausgabe der id beim entschlüsseln, 
//     test hash der b59 minilock ids

#include <getopt.h>  

#include <sodium/crypto_scalarmult.h>
#include <sodium/crypto_secretbox.h>
#include <sodium/crypto_box.h>
#include <sodium/utils.h>
#include <sodium/randombytes.h>

#include "json/json.h"
#include "libb64/b64/cencode.h"
#include "libb64/b64/cdecode.h"
#include "blake2/blake2.h"
#include "b58/base58.h"
#include "scrypt/crypto/crypto_scrypt.h"

#include "utils.h"

#define VERSION "0.1"

int decode_file(FILE* input_file, long eof_pos, uint8_t* b_file_nonce_prefix, uint8_t* b_file_key, uint8_t *c_override_out_name)
{
    unsigned char b_file_nonce[KEY_LEN-8]={0};
    unsigned char b_nonce_cnt[8]={0};
    unsigned char b_block_len[4]={0};
      
    FILE *output_file=0;
    int exit=0;
    int num_chunks=0;
    int chunk_len =0;
    int ret_val = EXIT_FAILURE;

    memcpy(b_file_nonce, b_file_nonce_prefix, NONCE_PREFIX_LEN);
    
    while (!exit) {
      
      fread(&b_block_len, 1, sizeof(b_block_len), input_file);
      if (feof(input_file) || ferror(input_file)){
	     return 1;
      }
      
      chunk_len = array_to_number(b_block_len, 4) +MAC_LEN;
      uint8_t* b_chunk = (uint8_t*)malloc(chunk_len);
      uint8_t* b_decrypt_block= (uint8_t*)malloc(chunk_len);
      
      fread(b_chunk, 1, chunk_len, input_file);
	
      number_to_array(b_nonce_cnt, sizeof(b_nonce_cnt), num_chunks++);
      
      if (eof_pos   == ftell(input_file)) {
	b_nonce_cnt[7] |= 128;
	exit=1;
	ret_val = EXIT_SUCCESS;
      }
      memcpy(b_file_nonce+NONCE_PREFIX_LEN, b_nonce_cnt, sizeof(b_nonce_cnt));
    
      int file_dec_retval  = crypto_secretbox_open_easy(b_decrypt_block, b_chunk,
					  chunk_len,b_file_nonce ,
					  (const unsigned char *)b_file_key);
      
      if (file_dec_retval) {
	  exit=1;
	  goto error_on_write;
	}
      
      if (num_chunks==1){
	
	uint8_t* dest_file  =  (strlen((char*)c_override_out_name)) ? c_override_out_name : b_decrypt_block;

        printf("Writing to file %s\n", dest_file);
	output_file = fopen((char *)dest_file, "wb");
	if (!output_file) {
	  fprintf(stderr, "ERROR: could not write to file %s\n", dest_file);
	  exit=1;
	  goto error_on_write;
	}
      } else { 
	if (fwrite(b_decrypt_block, 1, chunk_len-MAC_LEN, output_file) < chunk_len-MAC_LEN) {
	  exit=1;
	  goto error_on_write; 
	}
      }    
      sodium_memzero(b_decrypt_block, chunk_len);

error_on_write:
      free(b_decrypt_block);
      free(b_chunk);
    }
    
    fclose(output_file);
    return ret_val;
}

//TODO infile ab "/" abschneiden

int encode_file(FILE* output_file, uint8_t* b_file_nonce_prefix, uint8_t* b_file_key, uint8_t *c_input_file)
{
    int ret_val = EXIT_FAILURE;
    
    FILE *input_file = fopen((char*)c_input_file, "r+b");
    if(input_file == NULL) {
      fprintf(stderr, "ERROR: could not open file %s\n", c_input_file);
      return ret_val;
    }
   
    unsigned char b_file_nonce[KEY_LEN - 8]={0};
    memcpy(b_file_nonce, b_file_nonce_prefix, NONCE_PREFIX_LEN);
    
    unsigned char b_nonce_cnt[8]={0};
    unsigned char b_block_len[4]={0};
 
    int exit=0;
    int num_chunks=0;
    char b_crypt_block[BUF_READ_FILE] = {0};

    // Encode filename in the first chunk
    char b_read_buffer[BUF_READ_FILE] = {0};
    char *sep_pos = strrchr((const char*)c_input_file, '/'); //drop path
      
    strncpy(b_read_buffer, (sep_pos) ? (const char*)sep_pos+1 : (const char*)c_input_file, 256-1 ); 
    crypto_secretbox_easy((unsigned char*)b_crypt_block, (unsigned char*)b_read_buffer,
			  256, b_file_nonce, b_file_key);
    
    //dump (" CRYPT ", b_crypt_block, 256 + MAC_LEN + 1);
   
    number_to_array2(b_block_len, sizeof(b_block_len), 256  );
    
    fwrite(b_block_len, 1, sizeof(b_block_len), output_file); 
    fwrite(b_crypt_block, 1, 256 + MAC_LEN, output_file); 
    
    // Encode the file
    while (!exit)
    {
      number_to_array(b_nonce_cnt, sizeof(b_nonce_cnt), ++num_chunks);
      size_t num_read = fread(&b_read_buffer, 1, sizeof(b_read_buffer), input_file);
	if ( ferror(input_file)){
	    fprintf(stderr, "ERROR: could not read file %s\n", c_input_file);
	    exit=1;
	}
	
	if (feof(input_file)){
	  exit = 1;
	  b_nonce_cnt[7] |= 128;  
	  ret_val = EXIT_SUCCESS;
	}

        memcpy(b_file_nonce+NONCE_PREFIX_LEN, b_nonce_cnt, sizeof(b_nonce_cnt));
	//dump ("file b_file_nonce ", b_file_nonce,KEY_LEN - 8);
	crypto_secretbox_easy((unsigned char*)b_crypt_block, (unsigned char*)b_read_buffer, num_read, b_file_nonce, b_file_key);
	
	//printf("num_read: %d\n", num_read);
	number_to_array2(b_block_len, sizeof(b_block_len), num_read  );
	//dump ("file b_block_len ", b_block_len,4);
    
	fwrite(b_block_len, 1, sizeof(b_block_len), output_file); 
	fwrite(b_crypt_block, 1, num_read + MAC_LEN, output_file); 
	  
	if ( ferror(output_file)){
	    fprintf(stderr, "ERROR: could not write output file\n");
	    exit=1;
	}
	
    }
   
   fclose(input_file);
    return ret_val;
}

int minilock_encode(uint8_t* c_filename, uint8_t* c_sender_id, uint8_t* b_recipient_sk, uint8_t* b_recipient_pk, char**c_rcpt_list, int num_rcpts, uint8_t *c_override_out_name) {

	int ret_val = EXIT_FAILURE;

       if(num_rcpts==0) {
	  fprintf(stderr, "ERROR: no recipients defined\n");
	  return ret_val;
        }

	char c_out_file[256] = {0};
	
	
	if ( strlen((char*)c_override_out_name) ){
	  snprintf(c_out_file, sizeof(c_out_file)-1, "%s", c_override_out_name);
	} else {
	  snprintf(c_out_file, sizeof(c_out_file)-1, "%s.minilock", c_filename);
	}
	  
	//snprintf(c_out_file, sizeof(c_out_file)-1, "%s.minilock", c_filename);
	FILE *output_file = fopen((char*)c_out_file, "w+b");
	if(output_file == NULL) {
	  fprintf(stderr, "ERROR: could not open file %s\n", c_out_file);
	  return ret_val;
	}
	
	//Reserve 4 bytes for the length
	uint8_t b_header[12] = {'m','i','n','i','L','o','c','k', 0, 0, 0, 0};
	fwrite(b_header, 1, sizeof(b_header), output_file);        
        fwrite("{\"version\":1,", 1, 13, output_file);
	
	uint8_t  b_ephemeral_rnd[KEY_LEN]= {0};
	uint8_t  b_ephemeral_pk[KEY_LEN]= {0};
	uint8_t  b_file_key_rnd[KEY_LEN]= {0};
	uint8_t  b_file_nonce_rnd[KEY_LEN - 16]= {0};
	uint8_t  b_sending_nonce_rnd[KEY_LEN - 8]= {0};
	
	uint8_t  *c_ephemeral = 0;
	uint8_t  *c_file_key = 0;
	uint8_t  *c_file_nonce = 0;
	uint8_t  *c_sending_nonce = 0;
	uint8_t  *c_file_hash = 0;
	uint8_t  *c_file_info_crypted=0;
	uint8_t  *c_decrypt_item_crypted=0;
	
	char     c_ephemeral_json[128] = {0};
	char     c_file_info_json[256] = {0};
	char     c_decrypt_info_item_json[1024] = {0};
	char     c_decrypt_info_array_item_json[1024] = {0};
	
	int i=0;
	
	randombytes_buf(b_ephemeral_rnd, sizeof(b_ephemeral_rnd));
	randombytes_buf(b_file_key_rnd, sizeof(b_file_key_rnd));
	randombytes_buf(b_file_nonce_rnd, sizeof(b_file_nonce_rnd));
	
	//dump("b_ephemeral_rnd", b_ephemeral_rnd, 32);
	//c_ephemeral  = base64_encode((const char *)b_ephemeral_rnd, sizeof (b_ephemeral_rnd));
	c_file_key  = base64_encode((const char *)b_file_key_rnd, sizeof (b_file_key_rnd));
	c_file_nonce  = base64_encode((const char *)b_file_nonce_rnd, sizeof (b_file_nonce_rnd));
	
	
	
		crypto_scalarmult_base(b_ephemeral_pk, b_ephemeral_rnd);
	  c_ephemeral  = base64_encode((const char *)b_ephemeral_pk, sizeof (b_ephemeral_pk));
	
	snprintf(c_ephemeral_json, sizeof(c_ephemeral_json)-1, "\"ephemeral\":\"%s\",", c_ephemeral);
	fwrite(c_ephemeral_json, 1, strlen(c_ephemeral_json), output_file);
	
	fwrite("\"decryptInfo\":{", 1, 15, output_file);
	
	long decrypt_info_block_start = ftell(output_file);
	
	//Reserve  bytes for the decryptInfo items
	for (i=0; i<num_rcpts*550+2; i++){
	  fwrite("\x20", 1, 1, output_file);
	}
	//\x20

        fwrite("}}", 1, 2 , output_file);
	
	long crypt_block_start = ftell(output_file);
	unsigned char b_json_header_len[4]={0};
	// - magic len + len bytes + bin suffix after json header
	number_to_array2(b_json_header_len, sizeof(b_json_header_len), crypt_block_start - 12);
	fseek(output_file, 8, SEEK_SET);
	fwrite(b_json_header_len, 1, sizeof(b_json_header_len) , output_file);
	fseek(output_file, crypt_block_start, SEEK_SET);
	
	if (encode_file(output_file, b_file_nonce_rnd, b_file_key_rnd, c_filename))
	      goto free_res_encode;
	  	
	fseek(output_file, crypt_block_start, SEEK_SET);
	
	unsigned char b_hash[KEY_LEN] = {0};
	
	printf("Calculating file hash...\n");
	
	if( blake2s_stream( output_file, b_hash ) < 0 )
	{
	  goto free_res_encode;
	}

	c_file_hash  = base64_encode((const char *)b_hash, sizeof (b_hash));		
	snprintf(c_file_info_json, sizeof(c_file_info_json)-1, "{\"fileKey\":\"%s\",\"fileNonce\":\"%s\",\"fileHash\":\"%s\"}", c_file_key, c_file_nonce, c_file_hash);
	//printf("fileInfo %s\n", c_file_info_json);
	
	int file_info_len  = strlen(c_file_info_json);
	uint8_t b_rcpt_list_pk[KEY_LEN + 1]={0};
	char b_crypt_block[1024] = {0};


	for (i=0; i<num_rcpts; i++){
	  
	  randombytes_buf(b_sending_nonce_rnd, sizeof(b_sending_nonce_rnd));
	  c_sending_nonce  = base64_encode((const char *)b_sending_nonce_rnd, sizeof (b_sending_nonce_rnd));
	  
	  base58_decode(b_rcpt_list_pk, (unsigned char*)c_rcpt_list[i]);
	//  dump ("rcpt public ", b_rcpt_list_pk, 33);
	  b_rcpt_list_pk[KEY_LEN]=0;
	  
	  if (crypto_box_easy((unsigned char*)b_crypt_block, (unsigned char*)c_file_info_json, file_info_len, b_sending_nonce_rnd, b_rcpt_list_pk, b_recipient_sk)){
	    goto free_res_encode; //FIXME
	  }

	/////  dump ("fileinfo CRYPT ", b_crypt_block, file_info_len + 16 + 1);
	  c_file_info_crypted  = base64_encode((const char *)b_crypt_block, file_info_len +16);
	//  printf("\nfileinfo b64 %s\n", c_file_info_crypted);
	

	  snprintf(c_decrypt_info_item_json, sizeof(c_decrypt_info_item_json)-1, "{\"senderID\":\"%s\",\"recipientID\":\"%s\",\"fileInfo\":\"%s\"}", c_sender_id, c_rcpt_list[i], c_file_info_crypted);
	//  printf("c_decrypt_info_item_json %s\n", c_decrypt_info_item_json);
	  int decrypt_info_len  = strlen(c_decrypt_info_item_json);
	
	  //crypto_box_easy(ciphertext, MESSAGE, MESSAGE_LEN, nonce, bob_publickey, alice_secretkey);
	  if (crypto_box_easy((unsigned char*)b_crypt_block, (unsigned char*)c_decrypt_info_item_json, decrypt_info_len, b_sending_nonce_rnd, b_rcpt_list_pk, b_ephemeral_rnd)){
	    goto free_res_encode; //FIXME
	}
	//  dump ("decrypt_info_ CRYPT ", b_crypt_block, decrypt_info_len + 16 + 1);
	  c_decrypt_item_crypted  = base64_encode((const char *)b_crypt_block, decrypt_info_len +16);
	//  printf("\ndecrypt_info_ b64 %s\n", c_decrypt_item_crypted);
	 
	  snprintf(c_decrypt_info_array_item_json, sizeof(c_decrypt_info_array_item_json)-1, "\"%s\":\"%s\"%c", c_sending_nonce, c_decrypt_item_crypted,  (num_rcpts >1 && i<num_rcpts-1) ? ',':'\x20' );
	
	    int decrypt_info_array_item_len  = strlen(c_decrypt_info_array_item_json);
	    
	    
printf("\nc_decrypt_info_array_item_json b64 %s -> %d len\n", c_decrypt_info_array_item_json,decrypt_info_array_item_len);
	
	
	  if (decrypt_info_array_item_len<500){
	  
	    goto free_res_encode_loop; //FIXME
	}
	  
	  fseek(output_file, decrypt_info_block_start + i* 550, SEEK_SET);
	  
	  fwrite(c_decrypt_info_array_item_json, 1, decrypt_info_array_item_len , output_file);
	  
	  if ( ferror(output_file)){
	    fprintf(stderr, "ERROR: could not write output file\n");
	  } else {
	    if (i==num_rcpts-1) ret_val = EXIT_SUCCESS; 
	  }
	  
free_res_encode_loop:	
	  free(c_file_info_crypted);
	  c_file_info_crypted=0;
	  free(c_decrypt_item_crypted);
	  c_decrypt_item_crypted=0;
	  free (c_sending_nonce);
	  c_sending_nonce=0;
	}
	
free_res_encode:
	free (c_ephemeral);
	free (c_file_key);
	free (c_file_nonce);
	
	free (c_file_hash);
	
	
	fclose(output_file);
	return ret_val;
}


int minilock_decode(uint8_t* c_filename, uint8_t* b_recipient_sk, uint8_t* b_recipient_pk, uint8_t *c_override_out_name) {
  
	int ret_val = EXIT_FAILURE;
	
	uint8_t *b_ephemeral=0;
	uint8_t *b_nonce  = 0;
	uint8_t *b_decrypt_info  = 0;
	char    *c_json_buffer = 0;

	uint8_t *b_file_key=0;
	uint8_t *b_file_nonce=0;
	uint8_t *b_file_hash=0;
	
	uint8_t* b_sender_id = 0;
	uint8_t* b_recipient_id = 0;
	uint8_t *b_file_info=0;
	
	int b64_fileinfo_cnt, b58_sender_cnt, b58_rcpt_cnt;   
	int b64_cnt_key, b64_cnt_nonce, b64_cnt_hash ;
		
	json_value * json_header = 0;
	json_value * json_file_info =0;
	json_value * json_file_desc = 0;
	 
	FILE *input_file = fopen((char*)c_filename, "r+b");
	if(input_file == NULL) {
	  fprintf(stderr, "ERROR: could not open file %s\n", c_filename);
	  return ret_val;
	}
	
	uint8_t b_header[12] = {0};
	fread(&b_header, 1, sizeof(b_header), input_file);
	if (feof(input_file) || ferror(input_file)){
	    fprintf(stderr, "ERROR: could not read file %s\n", c_filename);
	    goto free_res;
	}
	
	if (strncmp((const char *)b_header, "miniLock", 8)) {
	    fprintf(stderr, "ERROR: invalid file format\n");
	    goto free_res; 
	}
	
	int json_header_len = array_to_number(b_header + 8, 4);
	
	c_json_buffer = malloc(json_header_len);
	
	if (fread(c_json_buffer, 1, json_header_len, input_file) < json_header_len) {
	    goto free_res;
	}
	
	//printf("c_json_buffer: %s", c_json_buffer);
	
	json_header = json_parse (c_json_buffer, json_header_len );
	
	if (!json_header || json_header->type!=json_object) {
	   //fprintf(stderr, "ERROR 1\n");
	    goto free_res;
	}
	
	int b64_cnt, b_64_epem_cnt;
	
	
	if (get_json_integer(json_header, "version")!=1){
		  printf("WARNING: minilock file version mismatch\n");
	}
	
	b_ephemeral=get_json_b64_string(json_header, "ephemeral", &b_64_epem_cnt);
	
	if (!b_ephemeral || b_64_epem_cnt != KEY_LEN) {
	  //fprintf(stderr, "ERROR 2\n");
	  goto free_res;
	}
	
	//dump("ephemeral", b_ephemeral, 32);
	
	json_value* json_decrypt_info = get_json_value (json_header, "decryptInfo");
	if (!json_decrypt_info) {
	  //fprintf(stderr, "ERROR 3\n");
	  goto free_res;
	}
	
	for (int i = 0; i < json_decrypt_info->u.object.length; i++) {
	      
	    b_nonce  =        base64_decode(json_decrypt_info->u.object.values [i].name, &b64_cnt);
	    b_decrypt_info  = base64_decode(json_decrypt_info->u.object.values [i].value->u.string.ptr, &b64_cnt);
	    char c_decoded_file_desc[512] = {0};
	    
	    //crypto_box_open_easy(decrypted, ciphertext, CIPHERTEXT_LEN, nonce alice_publickey, bob_secretkey) 
	    int open_retval =crypto_box_open_easy(( unsigned char *)c_decoded_file_desc, 
					  (const unsigned char *)b_decrypt_info, b64_cnt,
					  (const unsigned char *)b_nonce, b_ephemeral, b_recipient_sk);

	    if (open_retval){
	      free (b_nonce);b_nonce=0;
	      free (b_decrypt_info);b_decrypt_info=0;
	      //fprintf(stderr, "ERROR 4\n");
	      continue;
	    }
	     
	  //  printf("\nVAL crypto_box_open_easy  %d %s\n", open_retval, c_decoded_file_desc);
	    
	    json_file_desc = json_parse (c_decoded_file_desc, strlen(c_decoded_file_desc) );
    
	    sodium_memzero(c_decoded_file_desc, sizeof (c_decoded_file_desc));
	    
	    if (!json_file_desc || json_file_desc->type!=json_object) {
	      //fprintf(stderr, "ERROR 5\n");
	      goto exit_on_failure;
	    }
	    
	    uint8_t c_decoded_file_path[256] = {0};
	    b_sender_id = get_json_b58_string(json_file_desc, "senderID", &b58_sender_cnt);
	    b_recipient_id = get_json_b58_string(json_file_desc, "recipientID", &b58_rcpt_cnt);
	    b_file_info=get_json_b64_string(json_file_desc, "fileInfo", &b64_fileinfo_cnt);
	    
	    if (!b_file_info || !b_sender_id || !b_recipient_id || b58_sender_cnt!=KEY_LEN+1 || b58_rcpt_cnt!=KEY_LEN+1 ) {
	      //fprintf(stderr, "ERROR 6\n");
	      goto exit_on_failure;
	    }
			
	    uint8_t b_cs[1];
	    blake_2s_array(b_recipient_id, KEY_LEN , b_cs, sizeof(b_cs));
	    
	    if (b_cs[0]!=b_recipient_id[KEY_LEN]) {
	      //fprintf(stderr, "ERROR 6\n");
	      goto exit_on_failure;
	    }
	    if (memcmp(b_recipient_pk, b_recipient_id, KEY_LEN)) {
	      //fprintf(stderr, "ERROR 7\n");
	      goto exit_on_failure;
	}
	    blake_2s_array(b_sender_id, KEY_LEN , b_cs, sizeof(b_cs));
	    
	    if (b_cs[0]!=b_sender_id[KEY_LEN]) {
	      //fprintf(stderr, "ERROR 8\n");
	      goto exit_on_failure;
	    }
	
	    int open_fi_retval =crypto_box_open_easy((unsigned char *)c_decoded_file_path, 
				  (const unsigned char *)b_file_info, b64_fileinfo_cnt,
				  (const unsigned char *)b_nonce,
				  b_sender_id, b_recipient_sk);
	   // printf("\nVAL crypto_box_open_easy  %d %s\n", open_fi_retval, c_decoded_file_path);
	    
	    if (open_fi_retval){
	     //fprintf(stderr, "ERROR 9\n");
	      goto exit_on_failure;
	    }
	
	    json_file_info = json_parse ((const char *)c_decoded_file_path, strlen((const char*)c_decoded_file_path) );

	    sodium_memzero(c_decoded_file_path, sizeof (c_decoded_file_path));
	    
	    if (!json_file_info || json_file_info->type!=json_object) {
	      //fprintf(stderr, "ERROR 10\n");
	      goto exit_on_failure;
	    }
	    
	    b_file_key=get_json_b64_string(json_file_info, "fileKey", &b64_cnt_key);
	    b_file_nonce=get_json_b64_string(json_file_info, "fileNonce", &b64_cnt_nonce);
	    b_file_hash=get_json_b64_string(json_file_info, "fileHash", &b64_cnt_hash);
	  
	    if (b64_cnt_key != KEY_LEN || b64_cnt_nonce != NONCE_PREFIX_LEN ||  b64_cnt_hash != KEY_LEN) {
	      //fprintf(stderr, "ERROR 11\n");
	      goto exit_on_failure;
	    }
	    if (!b_file_key || !b_file_nonce || !b_file_hash) {
	      //fprintf(stderr, "ERROR 12\n");
	      goto exit_on_failure;
	    }
	    
	    long crypt_block_start = ftell(input_file);
	    
	    //TODO sollte das nicht 32 sein?
	    printf("Calculating file hash...\n");
	    //unsigned char hash[BLAKE2B_OUTBYTES] = {0};
	    
	    unsigned char hash[KEY_LEN] = {0};
	    if( blake2s_stream( input_file, hash ) < 0 )
	    {
	      //fprintf(stderr, "ERROR 13\n");
	      goto exit_on_failure;
	    } else if (memcmp(hash, b_file_hash, KEY_LEN)){
	      //fprintf(stderr, "ERROR 14\n");
	      goto exit_on_failure;
	    }

	    fseek(input_file, 0, SEEK_END);
	    long eof_pos   = ftell(input_file);
	    fseek(input_file, crypt_block_start, SEEK_SET);
	    
	    
	    if (decode_file(input_file, eof_pos, b_file_nonce, b_file_key, c_override_out_name)){
	      //fprintf(stderr, "ERROR 15\n");
	      goto exit_on_failure;
	    }
	    
	    ret_val = EXIT_SUCCESS;
		    
exit_on_failure:
	    free (b_file_key);  
	    free (b_file_nonce);
	    free (b_file_hash); 
	    
	    free(b_file_info);
	    free(b_sender_id);
	    free(b_recipient_id);
	    json_value_free (json_file_desc);
	    json_value_free (json_file_info);
	    
	    goto free_res;
	    
	} // loop decryptInfo

free_res:
	free(b_nonce);
	free(b_decrypt_info);
	free(b_ephemeral);
	free(c_json_buffer);
	
	json_value_free (json_header);
	
	fclose(input_file);
	
	
	return ret_val;
}


/******************************************************************************/
int main(int argc, char **argv)
{

      if (argc == 1) {
	  printf("USAGE: mlock [OPTIONS]\n");
	  return EXIT_FAILURE;
      } 
      uint8_t c_user_passphrase[256] = {0};
      uint8_t c_user_salt[256]  = {0};
      uint8_t c_input_file[256]  = {0};
      uint8_t c_output_file[256]  = {0};
      int do_enc=0, do_dec=0;
      int c;
      uint8_t key;
      int exclude_me =0;
      
      char* c_rcpt_list[51]= {0};
      int num_rcpts=0;
      uint8_t b_cs[1];
       uint8_t b_rcpt_pk[KEY_LEN + 1]={0};

      while (1) {
	  int option_index = 0;
	  static struct option long_options[] = {
	      {"encypt",  required_argument, 0,  'E' },
	      {"decrypt", required_argument, 0,  'D' },
	      {"output",  required_argument, 0,  'o' },
	      {"quiet",   no_argument,       0,  'q' },
	      {"version", no_argument,       0,  'v' },
	      {"help", no_argument,          0,  'h' },
	      {"exclude-me", no_argument,    0,  'x' },
	      {"salt",    required_argument, 0,  's'},
	      {"rcpt",    required_argument, 0,  'r' },
	      {0,         0,                 0,  0 }
	  };

	  c = getopt_long(argc, argv, "E:D:o:qvhs:r:x",
		  long_options, &option_index);
	  if (c == -1)
	      break;
	  switch (c) {

	  case 's':
	      snprintf((char *)c_user_salt, sizeof(c_user_salt)-1, optarg);
	      break;

	      case 'o':
	      snprintf((char *)c_output_file, sizeof(c_output_file)-1, optarg);
	      break;

	      
	  case 'v':
	    printf("mlock version " VERSION "\n");
	    printf("Copyright 2014 Andre Simon\n");
	    return EXIT_SUCCESS;

	  case 'h':
	    printf("USAGE: mlock [OPTION]...\n");
	    printf("mlock reads and writes encryped miniLock files (https://minilock.io/)\n\n");
	    printf("Available options:\n\n");
	    printf("  -E, --encrypt <file>  Encrypt the given file (see -r)\n");
	    printf("  -D, --decrypt <file>  Decrypt the given miniLock-file\n");
	    printf("  -o, --output <file>   Override the target file name (assumes -D or -E)\n");
	    printf("  -s, --salt <string>   User salt (i.e. mail address)\n");
	    printf("  -r, --rcpt <string>   Recipient's miniLock ID (may be repeated up to 50x, assumes -E)\n");
	    printf("  -x, --exclude-me      Exlude own miniLock ID from recipient list (assumes -E)\n");
	    
	    printf("  -q, --quiet           Reserved\n");
	    printf("  -h, --help            Print this help screen\n");
	    printf("  -v, --version         Print version information\n\n");
	    printf("If neither -E nor -D is given, mlock exits after showing your miniLock ID.\n");
	    return EXIT_SUCCESS;
	    
	  case 'D':   
	  case 'E':
	      do_dec=c=='D';
	      do_enc=!do_dec;
	      snprintf((char *)c_input_file, sizeof(c_input_file)-1, optarg);
	      break;
	      
	  case 'r':
	    base58_decode(b_rcpt_pk, (const unsigned char*)optarg);
	    blake_2s_array(b_rcpt_pk, KEY_LEN , b_cs, sizeof(b_cs));
	    if (b_cs[0]!=b_rcpt_pk[KEY_LEN]) {
	      fprintf(stderr, "ERROR: invalid Minilock ID: %s\n", optarg);
	      return EXIT_FAILURE;
	    }
	    c_rcpt_list[num_rcpts] = (char*)malloc(strlen(optarg)+1);
	    sprintf(c_rcpt_list[num_rcpts], optarg);
	    num_rcpts++;
	    break;
	  case 'x':
	    exclude_me = 1;
	    break;
	  case  '?':
	    return EXIT_FAILURE;
	  default:
	      break;
	  }
      }
 
 
    // Catch the most popular signals. 
    if((long) signal(SIGINT,sigcatch) < 0)
    {
        perror("signal");
        exit(EXIT_FAILURE);
    }
    if((long)signal(SIGQUIT,sigcatch) < 0)
    {
        perror("signal");
        exit(EXIT_FAILURE);
    }
    if((long) signal(SIGTERM,sigcatch) < 0)
    {
        perror("signal");
        exit(EXIT_FAILURE);
    }

    // Set raw mode on stdin. 
    if(ttyraw(0) < 0)
    {
        fprintf(stderr,"Can't go to raw mode.\n");
        exit(EXIT_FAILURE);
    }

    printf( "Please enter your secret passphrase:\r\n");
    int pp_idx=0;
    while( (read(0, &key, 1)) == 1 && pp_idx < sizeof(c_user_passphrase)-1)
    {
      key &= 255;
      if( key == 0xd || key==0x03) /* ASCII RETURN / CTRL+C */
            break;
	
//      if ((key &= 255) == 0x7f && pp_idx>0) /* ASCII DELETE */
//	    pp_idx--;
  //    else
	c_user_passphrase[pp_idx++] = key;
    }
    
    if (pp_idx<40)
      printf( "\nWarning: using a phrase with low entropy may be refused by the original Minilock.io Chrome extension.\r\n");

    if(ttyreset(0) < 0)
    {
        fprintf(stderr, "Cannot reset terminal!\n");
        exit(EXIT_FAILURE);
    }
  
      printf("Unlocking...\n");
      
      uint8_t b_passphrase_blake2[KEY_LEN] = {0};
      uint8_t b_recipient_sk[KEY_LEN] = {0};
	  
      blake_2s_array(c_user_passphrase, strlen((char *)c_user_passphrase), 
		      b_passphrase_blake2, KEY_LEN);

      int scrypt_retval= crypto_scrypt(b_passphrase_blake2, KEY_LEN, 
					    (const uint8_t *)c_user_salt, strlen((char *)c_user_salt), 
					    131072, 8, 1, 
					    b_recipient_sk, sizeof (b_recipient_sk));      
      if (scrypt_retval){
	  fprintf(stderr, "ERROR: key derivation failed\n");
	  return EXIT_FAILURE;
      }
      
      uint8_t b_recipient_pk[KEY_LEN + 1]={0};
      uint8_t c_minilock_id[KEY_LEN * 2]={0};
      crypto_scalarmult_base(b_recipient_pk, b_recipient_sk);
      
      blake_2s_array(b_recipient_pk, KEY_LEN , b_cs, sizeof(b_cs));
      b_recipient_pk[KEY_LEN] = b_cs[0];
      
      base58_encode((unsigned char *)c_minilock_id, b_recipient_pk, KEY_LEN + 1);
      
      printf("Your miniLock-ID: %s\n", c_minilock_id);
      
      if (!exclude_me){
	    c_rcpt_list[num_rcpts] = malloc(strlen((char*)c_minilock_id)+1);
	    sprintf(c_rcpt_list[num_rcpts], (char*)c_minilock_id);
	    num_rcpts++;
      }
      
      if (do_dec || do_enc) {
	printf("%scrypting file %s...\n", do_enc ? "En" : "De", c_input_file);
      
	if (do_dec && minilock_decode(c_input_file, b_recipient_sk, b_recipient_pk, c_output_file))
	  fprintf(stderr, "ERROR: file decryption failed: %s\n", c_input_file);
	else if (do_enc && minilock_encode(c_input_file, c_minilock_id, b_recipient_sk, b_recipient_pk, c_rcpt_list, num_rcpts, c_output_file))
	  fprintf(stderr, "ERROR: file encryption failed: %s\n", c_input_file);
	
	sodium_memzero(b_recipient_sk, sizeof (b_recipient_sk));
	printf("Task completed.\n");
      
      }
      
      
      while (num_rcpts) {
	free(c_rcpt_list[num_rcpts--]);
      }
	
      return EXIT_SUCCESS;
}

/*TODO Encryption errors

Error 1: General encryption error
Decryption errors

Error 2: General decryption error
Error 3: Could not parse header
Error 4: Invalid header version
Error 5: Could not validate sender ID
Error 6: File is not encrypted for this recipient
Error 7: Could not validate ciphertext hash
*/